<!DOCTYPE html>
<html>
<head>
<title>Brad Johnson: Fragment caching in Rails 4</title>
<meta content='Recently I implemented a nested caching scheme in a Rails application. I ran into a couple of interesting problems and found the documentation c...' name='description'>
<meta charset='utf-8'>
<meta content='width=device-width, initial-scale=1.0' name='viewport'>
<meta content='IE=edge' http-equiv='X-UA-Compatible'>
<meta content='True' name='HandheldFriendly'>
<link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />
<link href="/images/favicon.ico" rel="icon" type="image/ico" />
<link href="/stylesheets/application.css" rel="stylesheet" type="text/css" />
<link href='//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400' rel='stylesheet' type='text/css'>
</head>
<body class='post-template nav-closed'>
<div class='nav'>
<h3 class='nav-title'>Menu</h3>
<a class='nav-close' href='#'>
<span class='hidden'>Close</span>
</a>
<ul>
<li class='nav-home' role='presentation'>
<a href='/'>Home</a>
</li>
<li class='nav-github' role='presentation'>
<a href='https://github.com/cdale77'>GitHub</a>
</li>
</ul>
<a class='subscribe-button icon-feed' href='/feed.xml'>Subscribe</a>
</div>
<span class='nav-cover'></span>

<div class='site-wrapper'>
<header class='main-header no-cover post-head'>
<nav class='main-nav clearfix'>
<a class='menu-button icon-menu' href='#'>
<span class='word'>Menu</span>
</a>
</nav>
</header>
<main class='content' role='main'>
<article class='post'>
<header class='post-header'>
<h1 class='post-title'>Fragment caching in Rails 4</h1>
<section class='post-meta'>
<time class='post-date' datetime='2014-10-08'>
08 October 2014
</time>
on <a href='/tag/rails/'>rails</a>
</section>
</header>
<section class='post-content'><p>Recently I implemented a nested caching scheme in a Rails application. I ran
into a couple of interesting problems and found the documentation confusing, so
I thought I&rsquo;d write up what I did. This post is aimed at somebody new to 
caching. </p>

<h2>What is caching?</h2>

<p>In this post I&rsquo;m referring to caching as pre-generating chunks of html. Not 
caching database queries, pages, controller actions, etc. </p>

<h2>Why?</h2>

<p>Because it&rsquo;s fast. If you watch your server log, you&rsquo;ll see that rendering the
views takes quite a bit of time. At least for me, this was usually 10x or 20x 
the database query time. When you cache a part of a view, Rails does not have to
generate the html. This saves a ton of time. </p>

<h2>How?</h2>

<p>If you look at the 
<a href="http://guides.rubyonrails.org/caching_with_rails.html">Rails guide page on caching</a>
you&rsquo;ll see a bunch of stuff in there about page and action caching, along with 
a helpful note those things are deprecated in Rails 4. Also a link to a blog 
post by DHH (the &ldquo;founder&rdquo; of Rails) with an explanation of something called
key-based caching. </p>

<p>At first I found this all very confusing, but it can be really simple. The &ldquo;chunks&rdquo;
of pre-generated (cached) html are stored in an in-memory key-value store. The
value is the html. The key is created by you. </p>

<p>First, we need to worry about where we&rsquo;ll store these keys and values. Locally,
this is easy to set up based on the instructions in the Rails guide above. 
Production varies of course. Heroku has add-ons, I used 
<a href="https://www.memcachier.com/">Memecachier</a>. Works well for me. There is good 
documentation about this, so I&rsquo;ll ignore the setup details and focus on the code.</p>

<p>To cache a part of a view, wrap that code in a cache block:</p>
<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>&lt;% cache(my_cache_key) do %&gt;
  #cached erb, hml, html etc here
&lt;% end %&gt;
</pre></td></tr></tbody></table>
</div>

<p>The part to pay attention to is the keys. You want to create a key that will 
change when you want rails to re-generate the view code, but not change 
otherwise. Rails will look for a value for that key when a user asks for a page,
if the key doesn&rsquo;t exist that will force Rails to re-generate that view. If the
key is there, Rails will just served the cached copy. </p>

<p>A simple example would be for some static part of your page, perhaps
a footer:</p>
<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>&lt;% cache(["v1-footer") do $&gt;
  # some html 
&lt;% end %&gt;
</pre></td></tr></tbody></table>
</div>

<p>If you updated your footer view partial, then you would simply change the &ldquo;v1&rdquo;
string to &ldquo;v2-footer&rdquo;. The next time Rails renders the 
footer, it will look for a cache key &ldquo;v2-footer&rdquo;. It won&rsquo;t find one, so it will
render the footer and make a new cache entry. From then on, Rails will find that
key and all will be well. </p>

<p>You can take this simple idea and expand it to dynamic content. Let&rsquo;s say you 
have a view listing all the products a company sells. You want to cache this
view, but if you take the approach above, it won&rsquo;t be updated when a product 
changes. The solution is to create a cache key that changes when any product
changes, <em>and</em> when you want to manually change it (for example if you change
the view code). </p>
<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>&lt;% cache ["v1", cache_key_for_products] do %&gt;
  # Your index view here
&lt;% end %&gt;
</pre></td></tr></tbody></table>
</div>

<p>cache<em>key</em>for_products is simply a helper method that returns a string that
changes whenever any product is updated (this is straight from the Rails guide:</p>
<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre>module ProductsHelper
  def cache_key_for_products
    count          = Product.count
    max_updated_at = Product.maximum(:updated_at).try(:utc).try(:to_s, :number)
    "products/all-#{count}-#{max_updated_at}"
  end
end
</pre></td></tr></tbody></table>
</div>

<p>Rails will combine the &ldquo;v1&rdquo; with a string that will change when the a product is
updated. So the cache will be bust in the case of product change, and also when
you change the &ldquo;v1&rdquo; bit, probably because you updated the view code and you need
to re-generate all the cached html. </p>

<p>Ok, so we&rsquo;re pretty far along already. The final step is to set up a nested 
cache scheme. Why should we re-generate html for each product, when only one
has changed? Let&rsquo;s cache each table row, too. </p>
<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>&lt;% cache["v1", product] do %&gt;
  &lt;tr&gt;Great product&lt;/tr&gt;
&lt;% end %&gt;
</pre></td></tr></tbody></table>
</div>

<p>This will generate a cache entry with a key that combines the template version
(&ldquo;v1&rdquo;) with a fingerprint of the product record. By wrapping each row in a cache
block, then caching the whole table, we have a slick nested caching setup that
will minimized the time spent rendering views. Now, when one product is updated,
Rails simply needs to regenerate 1 table row, reassembly the already-cached other
rows, and we&rsquo;re all set. This is a lot faster than doing it all from scratch
every time. </p>

<p>So that&rsquo;s about it, as far as basics go. One note &ndash; there are other ways to do 
this. In this setup I describe, all cache keys are universal. I find that easier
to deal with, but you can also use the action or controller context to define 
keys. This is covered in the Rails guide. </p>

<h2>Gotchas</h2>

<p>What about paginated index views? If you&rsquo;re using will_paginate, this should
work:</p>
<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>&lt;% cache ["v1-#{params[:page]", cache_key_for_products] do %&gt;
  # Your index view here
&lt;% end %&gt;
</pre></td></tr></tbody></table>
</div>

<p>What about a paginated index view that also has a Ransack search form? </p>
<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>&lt;% cache ["v1-#{params[:page]-#{params[:q]", cache_key_for_products] do %&gt;
  # Your index view here
&lt;% end %&gt;
</pre></td></tr></tbody></table>
</div>
</section>
<footer class='post-footer'>
<section class='author'>
<h4>
<a href='/author/brad-johnson/'>Brad Johnson</a>
</h4>
<p></p>
Read
<a href='/author/brad-johnson/'>more posts</a>
by this author.
</section>
<section class='share'>
<h4>Share this post</h4>
<a class='icon-twitter' href='https://twitter.com/share?text=Fragment caching in Rails 4&amp;amp;url=http://www.bradleymosesjohnson.com/2014/10/08/fragment-caching-in-rails-4/' onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
<span class='hidden'>Twitter</span>
</a>
<a class='icon-facebook' href='https://www.facebook.com/sharer/sharer.php?u=http://www.bradleymosesjohnson.com/2014/10/08/fragment-caching-in-rails-4/' onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
<span class='hidden'>Facebook</span>
</a>
<a class='icon-google-plus' href='https://plus.google.com/share?url=http://www.bradleymosesjohnson.com/2014/10/08/fragment-caching-in-rails-4/' onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
<span class='hidden'>Google+</span>
</a>
</section>
</footer>
</article>
</main>
<aside class='read-next'>
<a class='no-cover read-next-story' href='/2014/08/19/rails-models/'>
<section class='post'>
<h2>ActiveRecord Models</h2>
<p>This post is a writeup of a RailsSchool class on 14-08-19 on ActiveRecord models. What is a model? In&hellip;</p>
</section>
</a>
<a class='no-cover prev read-next-story' href='/2014/12/15/rails-internationalization/'>
<section class='post'>
<h2>Rails Internationalization</h2>
<p>This post outlines an easy way to make Rails raise an exception when it finds missing I18n keys. This&hellip;</p>
</section>
</a>
</aside>

<footer class='site-footer clearfix'>
<section class='copyright'>
<a href='/'>Brad Johnson</a>
&copy;
2015
</section>
<section class='poweredby'>
Casper theme powered by
<a href='https://ghost.org'>Ghost</a>
</section>
</footer>
</div>
<script src="/javascripts/application.js" type="text/javascript"></script>
</body>
</html>
